/******************************************************************************************
 AWS RDS SQL SERVER PERFORMANCE OPTIMIZATION & BASELINE CHECKLIST
 Author: ChatGPT
 Description:
 This script collects performance and configuration data from a new AWS RDS SQL Server 
 instance to identify tuning opportunities. Safe to run — read-only.
******************************************************************************************/

/******************************************************************************************
 SECTION 1 — INSTANCE & MEMORY CONFIGURATION
******************************************************************************************/

-- Check current instance configuration and memory allocation
SELECT 
    SERVERPROPERTY('MachineName') AS ServerName,
    SERVERPROPERTY('Edition') AS Edition,
    SERVERPROPERTY('ProductVersion') AS Version,
    SERVERPROPERTY('EngineEdition') AS EngineEdition,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'max server memory (MB)') AS MaxServerMemory_MB,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'min server memory (MB)') AS MinServerMemory_MB,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'cost threshold for parallelism') AS CostThreshold,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'max degree of parallelism') AS MaxDOP,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'optimize for ad hoc workloads') AS OptimizeAdHoc,
    (SELECT value_in_use FROM sys.configurations WHERE name = 'remote admin connections') AS RemoteDACEnabled;

/*
INTERPRETATION:
 - OptimizeAdHoc should be 1
 - CostThreshold should be >= 30
 - MaxDOP: 1 for OLTP or 4–8 for mixed workloads
 - MaxServerMemory: leave 10–20% RAM for OS overhead
*/


/******************************************************************************************
 SECTION 2 — TEMPDB AND FILE GROWTH
******************************************************************************************/

USE tempdb;
SELECT 
    name AS FileName,
    type_desc,
    size/128 AS SizeMB,
    growth/128 AS GrowthMB,
    physical_name
FROM sys.database_files;

/*
INTERPRETATION:
 - Use multiple TempDB data files (1 per 2–4 vCPUs, up to 8 max)
 - Growth should be fixed MB (not %)
 - Files should be equal in size
*/


/******************************************************************************************
 SECTION 3 — INDEX AND FRAGMENTATION REPORT
******************************************************************************************/

DECLARE @db sysname = DB_NAME();
SELECT 
    DB_NAME() AS DatabaseName,
    OBJECT_NAME(ips.object_id) AS TableName,
    i.name AS IndexName,
    ips.avg_fragmentation_in_percent AS FragPct,
    ips.page_count AS PageCount
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') AS ips
JOIN sys.indexes AS i
    ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.avg_fragmentation_in_percent > 10 AND ips.page_count > 100
ORDER BY ips.avg_fragmentation_in_percent DESC;

/*
INTERPRETATION:
 - Rebuild indexes >30% fragmented
 - Reorganize indexes 10–30% fragmented
*/


/******************************************************************************************
 SECTION 4 — MISSING AND UNUSED INDEXES
******************************************************************************************/

-- Missing indexes (potential performance gain)
SELECT 
    DB_NAME(mid.database_id) AS DatabaseName,
    OBJECT_NAME(mid.object_id, mid.database_id) AS TableName,
    migs.user_seeks, migs.user_scans,
    mid.equality_columns, mid.inequality_columns, mid.included_columns
FROM sys.dm_db_missing_index_group_stats AS migs
JOIN sys.dm_db_missing_index_groups AS mig
    ON migs.group_handle = mig.index_group_handle
JOIN sys.dm_db_missing_index_details AS mid
    ON mig.index_handle = mid.index_handle
ORDER BY migs.user_seeks DESC;

-- Unused indexes (consume space + maintenance cost)
SELECT 
    DB_NAME() AS DatabaseName,
    OBJECT_NAME(i.object_id) AS TableName,
    i.name AS IndexName,
    user_seeks, user_scans, user_lookups, user_updates
FROM sys.dm_db_index_usage_stats AS s
JOIN sys.indexes AS i
    ON s.object_id = i.object_id AND s.index_id = i.index_id
WHERE OBJECTPROPERTY(i.object_id,'IsUserTable') = 1
ORDER BY user_updates DESC;

/*
INTERPRETATION:
 - Create missing indexes where seeks/scans are high
 - Drop unused indexes with zero seeks and high updates
*/


/******************************************************************************************
 SECTION 5 — WAIT STATS AND I/O BASELINE
******************************************************************************************/

-- Wait type summary (top 10 waits)
SELECT TOP 10 
    wait_type, 
    wait_time_ms/1000.0 AS WaitTimeSec,
    signal_wait_time_ms/1000.0 AS SignalWaitSec,
    waiting_tasks_count AS WaitCount
FROM sys.dm_os_wait_stats
WHERE wait_type NOT IN (
    'SLEEP_TASK','BROKER_TASK_STOP','SQLTRACE_BUFFER_FLUSH',
    'XE_TIMER_EVENT','XE_DISPATCHER_WAIT'
)
ORDER BY wait_time_ms DESC;

-- I/O latency baseline
SELECT 
    DB_NAME(vfs.database_id) AS DatabaseName,
    mf.physical_name,
    vfs.num_of_reads, vfs.num_of_writes,
    vfs.io_stall_read_ms, vfs.io_stall_write_ms,
    CAST((1.0 * vfs.io_stall_read_ms / NULLIF(vfs.num_of_reads,0)) AS DECIMAL(10,2)) AS AvgReadLatency_ms,
    CAST((1.0 * vfs.io_stall_write_ms / NULLIF(vfs.num_of_writes,0)) AS DECIMAL(10,2)) AS AvgWriteLatency_ms
FROM sys.dm_io_virtual_file_stats(NULL,NULL) AS vfs
JOIN sys.master_files AS mf
    ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
ORDER BY AvgReadLatency_ms DESC;

/*
INTERPRETATION:
 - AvgReadLatency / AvgWriteLatency should generally be < 5–10 ms for provisioned IOPS
 - High PAGEIOLATCH_* waits → storage bottleneck
 - High SOS_SCHEDULER_YIELD → CPU pressure
 - High CXPACKET/CXCONSUMER → parallelism tuning needed
*/


/******************************************************************************************
 SECTION 6 — OPTIONAL: AWS PARAMETER GROUP VALIDATION (CLI)
******************************************************************************************/

/*
Use AWS CLI to verify key DB Parameter Group settings:
aws rds describe-db-parameters \
--db-parameter-group-name <your-group-name> \
--query "Parameters[?ParameterName==`max degree of parallelism` || 
ParameterName==`cost threshold for parallelism` || 
ParameterName==`optimize for ad hoc workloads` || 
ParameterName==`max server memory (MB)`]"
*/

/*
END OF SCRIPT
******************************************************************************************/
